=head1 NAME

DBIx::Irian::Tutorial - Documentation for those new to Irian

=head1 SYNOPSIS

This is a brief tutorial for those interested in using
L<Irian|DBIx::Irian>. As such it is not intended to cover all the
details: for that see the main reference documentation.

=head1 DESCRIPTION

=head2 Databases

A system built using Irian has a single entry point, an object
inheriting from L<DBIx::Irian::DB|DBIx::Irian::DB>. This object holds
the connection to the database, and has methods for making queries.

A simple, self-contained database class might look like this:

    package My::DB;
    use DBIx::Irian "DB";

    setup_row_class Book => qw/id isbn title/;
    query book => Book => <<SQL;
        SELECT $Cols FROM $Q{book} WHERE $Q{isbn} = $Arg[0]
    SQL

    1;

and might be used like this

    my $DB = My::DB->new("dbi:Pg:");
    my $book = $DB->book("0596000278");

Even with such a relatively simple example, there's quite a lot
happening, so let's go through it.

=head2 Importing from C<Irian>

The first thing to notice is that C<warnings> and C<strict> are missing.
This is not accidental: C<use DBIx::Irian> does the equivalent of

    use strict;
    use warnings;
    use feature ":5.10";

for you. The next is the C<"DB"> argument to C<use>: this does two
things.

First, it sets up the current package to inherit from
L<DBIx::Irian::DB|DBIx::Irian::DB>. Second, it exports a number of
'syntactic sugar' subs into the current namespace, but arranges for them
to disappear again when the current scope has finished compiling. This
means you can have a method called (say) C<query> despite there being a
sugar by that name. These 'sugars' are the main interface for setting up
Irian subclasses.

=head2 Queries

Ignore the call to C<setup_row_class> for a moment, and look at the
call to C<query>:

    query book => Book => <<SQL;
        SELECT $Cols FROM $Q{book} WHERE $Q{isbn} = $Arg[0]
    SQL

This sets up a method to run a query, which will end up something like

    SELECT "id", "isbn", "title" FROM "book" WHERE "isbn" = ?

with the first argument to the method passed in as the value for the
placeholder. The second argument to C<query>, C<"Book">, asks for the
rows returned by the query to be packed up into C<My::DB::Book> objects.

=head2 Rows

This row class, C<My::DB::Book>, is a class you need to create yourself,
though Irian will load it for you when it is needed. It needs to inherit
from L<DBIx::Irian::Row|DBIx::Irian::Row>, and a simple case might look
like

    package My::DB::Book;
    use DBIx::Irian "Row";

    columns qw/id isbn title/;
    1;

This says that a query using the C<Book> row class is expected to
return rows with three columns, and those columns will be accessible
with the C<< ->id >>, C<< ->isbn >> and C<< ->title >> methods on the
row object.

Note that these are columns returned by the I<query>, not the columns on
the constituent tables which an ORM like C<DBIx::Class> would give you.
If a query joins across three tables and returns one field from each,
the row class still has three fields accessible directly from that
object. Note also that it's perfectly sensible to have several queries
use the same C<Row> if they return compatible data: for instance, you
might have C<< ->all_books >> and C<< ->book_by_title >> return C<Book>s
as well.

When a C<Row> class has nothing but a C<columns> declaration, you can
avoid creating a whole module file just for that by using
C<setup_row_class>. The call in C<My::DB>,

    setup_row_class Book => qw/id isbn title/;

is equivalent to the C<My::DB::Book> example above. If you want to do
more than that, you'll need a proper module file.

You can set up C<query> methods on a C<Row> class: this is how you make
queries for related records. So, for instance, we could have

    query authors => Author => <<SQL;
        SELECT $Cols FROM $Q{author} WHERE $Q{book} = $Self{id}
    SQL
    
which might look up authors based on the C<Book>'s C<< ->id >>.

=head2 Magic variables

By now you must be wondering about these variables that keep getting
interpolated into the SQL. The full documentation for them is in
L<DBIx::Irian::Query|DBIx::Irian::Query>, but the short version is that
they don't expand immediately, the expansion is deferred until the
method is called and the query is run. The most important are:

=over 4

=item %Q

This expands to an SQL identifier, properly quoted for the database you
are using.

=item $Cols

This expands to the column names of the C<Row> this query is using,
identifier-quoted and comma-separated. In simple cases this allows you
to fill in the C<SELECT> list without repeating yourself.

=item %Cols

An expression like C<$Cols{tab}> expands to the same column names (for
any given query) as C<$Cols>, but with the field names qualified with a
table name. So whereas C<$Cols> might expand to

    "one", "two", "three"

C<$Cols{table}> might expand to

    "table"."one", "table"."two", "table"."three"

This is useful when you need to join in other tables to select the rows
you want, and there might be column name conflicts.

=item %P

This expands to a C<"?"> placeholder, and arranges for the key used to
be passed to DBI as the corresponding bind value.

=item @Arg

This expands to a placeholder which will be bound to one of the
arguments passed to the method call. Arguments are numbered from 0,
discounting the implicit object argument.

=item %Self

This takes as a key the name of a method, and calls that method (with no
arguments) on the current object. The result is bound to a placeholder,
as with C<@Arg>.

=back

There are more, but they are less generally useful; see the
L<Query|DBIx::Irian::Query> documentation for details.

